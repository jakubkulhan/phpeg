<?php
class generate_common
{
    private $_stack = array();
    private $_env;
    private $_index;

    public function __construct()
    {
        $this->_init();
    }

    public function walk($node)
    {
        /*$this->_init();*/
        return $this->_walk($node);
    }

    public function walkeach(array $nodes)
    {
        /*$this->_init();*/
        return $this->_walkeach($nodes);
    }

    protected function _init()
    {
        $this->_env = array();
$self = (object) array(
        "inits" => array(),
        "initscount" => 0,
        "generator" => NULL,
    );

        $this->_env = get_defined_vars();
    }

    protected function _node()
    {
        return end($this->_stack);
    }

    protected function _nodetype()
    {
        return current($this->_node());
    }

    protected function _stack()
    {
        return $this->_stack;
    }

    protected function _root()
    {
        reset($this->_stack);
        return current($this->_stack);
    }

    protected function _index()
    {
        return $this->_index;
    }

    protected function _walkeach(array $nodes)
    {
        $ret = array();

        foreach ($nodes as $k => $node) {
            $this->_index = $k;
            $ret[$k] = $this->_walk($node);
        }

        return $ret;
    }

    protected function _walk($node)
    {
        array_push($this->_stack, $node);
        $ret = NULL;

        switch ($node[0]) {
        case 'toplevel_':
            list($_, $_0) = $node;
            $ret = $this->_0($_0);
        break;
        case 'namespace_':
            list($_, $_0, $_1) = $node;
            $ret = $this->_1($_0, $_1);
        break;
        case 'class_':
            list($_, $_0, $_1) = $node;
            $ret = $this->_2($_0, $_1);
        break;
        case 'constructor_':
            $ret = $this->_3();
        break;
        case 'init_':
            list($_, $_0, $_1) = $node;
            $ret = $this->_4($_0, $_1);
        break;
        case 'invoke_':
            list($_, $_0, $_1) = $node;
            $ret = $this->_5($_0, $_1);
        break;
        case 'format_':
            list($_, $_0) = $node;
            $ret = $this->_6($_0);
        break;
        default:
            $ret = $this->_7();
        break;
        }

        array_pop($this->_stack);
        return $ret;
    }

    public function __invoke($generator, $namespace, $name, $inits, $invoke)
    {
        /*$this->_init();*/
        extract($this->_env, EXTR_REFS);
        $self->generator = $generator;
        
            $all = array("class_", $name, array(
                array("prolog_"),
                array("constructor_")
            ));
        
            foreach ($inits as $i => $init) {
                list($for, $code) = $init;
        
                foreach ($for as $j) {
                    $self->inits[$j] = $i;
                }
        
                $all[2][] = array("init_", $i, $code);
        
                $self->initscount++;
            }
        
            $all[2][] = array("inits_", $self->inits);
        
            if ($invoke) {
                $all[2][] = array("invoke_", $invoke[0], $invoke[1]);
            } else {
                $all[2][] = array("invoke_", array("s"), "return \$this->parse(\$s);\n");
            }
        
            $all[2][] = array("parse_");
        
            if ($namespace) {
                $all = array("namespace_", $namespace, $all);
            }
        
            $all = array("toplevel_", $all);
        
            return $this->_walk($all);

    }

protected function _0($node) { extract($this->_env, EXTR_REFS); return "<?php\n" .
           "// autogenerated file, do not edit!\n" .
           $this->_walk($node);

}
protected function _1($namespace, $node) { extract($this->_env, EXTR_REFS); return "namespace $namespace {\n" .
               $this->_walk($node) .
           "}\n";

}
protected function _2($name, $nodes) { extract($this->_env, EXTR_REFS); return "class $name {\n" .
               i(implode("\n", $this->_walkeach($nodes))) .
           "}\n";

}
protected function _3() { extract($this->_env, EXTR_REFS); $inits = array();

    for ($i = 0; $i < $self->initscount; ++$i) {
        $inits[] = "\$this->_init$i();";
    }

    $inits = implode("\n", $inits) . "\n";

    return "private \$_envs = array();\n" .
           "public function __construct() {\n" .
               i($inits) .
           "}\n";

}
protected function _4($i, $code) { extract($this->_env, EXTR_REFS); return "private function _init$i() {\n" .
           "    \$this->_envs[$i] = array();\n" .
                i($code) .
           "    \$this->_envs[$i] = get_defined_vars();\n" .
           "}\n";

}
protected function _5($parameters, $code) { extract($this->_env, EXTR_REFS); foreach ($parameters as &$parameter) {
        $parameter = "$$parameter";
    }

    $parameters = implode(", ", $parameters);

    return "public function __invoke($parameters) {\n" .
               i($code) .
           "}\n";

}
protected function _6($s) { extract($this->_env, EXTR_REFS); if (empty($s)) {
        return $s;
    }

    $formatted = "";

    foreach (str_split($s) as $c) {
        if ($c === '\\') { $formatted .= '\\\\'; }
        else if ($c === '"') { $formatted .= '\\"'; }
        else if ($c === "'") { $formatted .= "\\'"; }
        else if (ctype_print($c) || $c === " ") { $formatted .= $c; }
        else if ($c === "\t") { $formatted .= '\t'; }
        else if ($c === "\n") { $formatted .= '\n'; }
        else if ($c === "\r") { $formatted .= '\r'; }
        else {
            $hex = dechex(ord($c));
            $formatted .= "\\x" . (strlen($hex) < 2 ? str_pad($hex, 2, "0", STR_PAD_LEFT) : $hex);
        }
    }

    return $formatted;

}
protected function _7() { extract($this->_env, EXTR_REFS); return $self->generator->walk($this->_node());
}

}
