<?php
class generate_common
{
    private $_stack = array();
    private $_env;
    private $_index;

    public function __construct()
    {
        $this->_init();
    }

    public function walk($node)
    {
        /*$this->_init();*/
        return $this->_walk($node);
    }

    public function walkeach(array $nodes)
    {
        /*$this->_init();*/
        return $this->_walkeach($nodes);
    }

    protected function _init()
    {
        $this->_env = array();
$self = (object) array(
        "inits" => array(),
        "generator" => NULL,
    );

        $this->_env = get_defined_vars();
    }

    protected function _node()
    {
        return end($this->_stack);
    }

    protected function _nodetype()
    {
        return current($this->_node());
    }

    protected function _stack()
    {
        return $this->_stack;
    }

    protected function _root()
    {
        reset($this->_stack);
        return current($this->_stack);
    }

    protected function _index()
    {
        return $this->_index;
    }

    protected function _walkeach(array $nodes)
    {
        $ret = array();

        foreach ($nodes as $k => $node) {
            $this->_index = $k;
            $ret[$k] = $this->_walk($node);
        }

        return $ret;
    }

    protected function _walk($node)
    {
        array_push($this->_stack, $node);
        $ret = NULL;

        switch ($node[0]) {
        case 'toplevel_':
            list($_, $_0) = $node;
            $ret = $this->_0($_0);
        break;
        case 'namespace_':
            list($_, $_0, $_1) = $node;
            $ret = $this->_1($_0, $_1);
        break;
        case 'class_':
            list($_, $_0, $_1) = $node;
            $ret = $this->_2($_0, $_1);
        break;
        case 'constructor_':
            $ret = $this->_3();
        break;
        case 'extract_environment_':
            $ret = $this->_4();
        break;
        case 'push_environment_':
            list($_, $_0) = $node;
            $ret = $this->_5($_0);
        break;
        case 'pop_environment_':
            $ret = $this->_6();
        break;
        case 'init_':
            list($_, $_0, $_1) = $node;
            $ret = $this->_7($_0, $_1);
        break;
        case 'invoke_':
            list($_, $_0, $_1) = $node;
            $ret = $this->_8($_0, $_1);
        break;
        case 'format_':
            list($_, $_0) = $node;
            $ret = $this->_9($_0);
        break;
        default:
            $ret = $this->_10();
        break;
        }

        array_pop($this->_stack);
        return $ret;
    }

    public function __invoke($generator, $namespace, $name, $inits, $invoke)
    {
        /*$this->_init();*/
        extract($this->_env, EXTR_REFS);
        $self->generator = $generator;
        
            $all = array("class_", $name, array(
                array("prolog_"),
                array("constructor_")
            ));
        
            $self->inits = $inits;
            foreach ($self->inits as $i => $code) {
                $all[2][] = array("init_", $i, $code);
            }
        
            if ($invoke) {
                $all[2][] = array("invoke_", $invoke[0], $invoke[1]);
            } else {
                $all[2][] = array("invoke_", array("s"), "return \$this->parse(\$s);\n");
            }
        
            $all[2][] = array("parse_");
        
            if ($namespace) {
                $all = array("namespace_", $namespace, $all);
            }
        
            $all = array("toplevel_", $all);
        
            return $this->_walk($all);

    }

protected function _0($node) { extract($this->_env, EXTR_REFS); return "<?php\n" .
           "// autogenerated file, do not edit!\n" .
           $this->_walk($node);

}
protected function _1($namespace, $node) { extract($this->_env, EXTR_REFS); return "namespace $namespace {\n" .
               $this->_walk($node) .
           "}\n";

}
protected function _2($name, $nodes) { extract($this->_env, EXTR_REFS); return "class $name {\n" .
               i(implode("\n", $this->_walkeach($nodes))) .
           "}\n";

}
protected function _3() { extract($this->_env, EXTR_REFS); $inits = array();

    for ($i = 0, $c = count($self->inits); $i < $c; ++$i) {
        $inits[] = "\$this->_init$i();";
    }

    $inits = implode("\n", $inits) . "\n";

    return "private \$_environments = array(-1 => array());\n" .
           "private \$_environment_stack = array();\n" .
           "private \$_environment_stack_sp = -1;\n" .
           "public function __construct() {\n" .
               i($inits) .
           "}\n";

}
protected function _4() { extract($this->_env, EXTR_REFS); return "extract(\$this->_environments[\$this->_environment_stack[\$this->_environment_stack_sp]], EXTR_OVERWRITE | EXTR_REFS);";;
}
protected function _5($env) { extract($this->_env, EXTR_REFS); return "\$this->_environment_stack[++\$this->_environment_stack_sp] = " . $env . ";";
}
protected function _6() { extract($this->_env, EXTR_REFS); return "unset(\$this->_environment_stack[\$this->_environment_stack_sp--]);";
}
protected function _7($i, $code) { extract($this->_env, EXTR_REFS); return "private function _init$i() {\n" .
           "    \$this->_environments[$i] = array();\n" .
                i($code) .
           "    \$this->_environments[$i] = get_defined_vars();\n" .
           "}\n";

}
protected function _8($parameters, $code) { extract($this->_env, EXTR_REFS); foreach ($parameters as &$parameter) {
        $parameter = "$$parameter";
    }

    $parameters = implode(", ", $parameters);

    return "public function __invoke($parameters) {\n" .
               "foreach (\$this->_environments as \$_env) { extract(\$_env, EXTR_OVERWRITE | EXTR_REFS); }\n" .
               i($code) .
           "}\n";

}
protected function _9($s) { extract($this->_env, EXTR_REFS); if (empty($s)) {
        return $s;
    }

    $formatted = "";

    foreach (str_split($s) as $c) {
        if ($c === '\\') { $formatted .= '\\\\'; }
        else if ($c === '"') { $formatted .= '\\"'; }
        else if ($c === "'") { $formatted .= "\\'"; }
        else if (ctype_print($c) || $c === " ") { $formatted .= $c; }
        else if ($c === "\t") { $formatted .= '\t'; }
        else if ($c === "\n") { $formatted .= '\n'; }
        else if ($c === "\r") { $formatted .= '\r'; }
        else {
            $hex = dechex(ord($c));
            $formatted .= "\\x" . (strlen($hex) < 2 ? str_pad($hex, 2, "0", STR_PAD_LEFT) : $hex);
        }
    }

    return $formatted;

}
protected function _10() { extract($this->_env, EXTR_REFS); return $self->generator->walk($this->_node());
}

}
